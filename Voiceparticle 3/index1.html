<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sound Particles: Resonance of You (Finale)</title>
<!-- Load Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden; /* Hide scrollbars */
    font-family: 'Inter', system-ui, Arial;
    background-color: #0f0f11;
    color: #fff;
    touch-action: manipulation; /* Improves touch responsiveness */
  }
  canvas {
    display: block;
    cursor: grab; /* Cue for 3D orbit control */
  }
  canvas:active {
    cursor: grabbing;
  }
  /* Custom styling for UI element appearance */
  #ui {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: opacity 0.3s ease, transform 0.3s ease;
  }
  
  /* --- HUD Elements --- */
  #tip-hud {
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    transition: opacity 0.5s ease-in-out;
    pointer-events: none; /* Make sure it doesn't block mouse interaction */
  }
  #phase-hud {
    background: rgba(0,0,0,0.3);
    backdrop-filter: blur(5px);
    pointer-events: none;
  }
  #phase-bar {
    transition: width 0.3s ease-out;
  }

  /* --- Action Bar --- */
  .action-btn {
    background-color: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 0.1);
    color: white;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .action-btn:hover {
    background-color: rgba(255, 255, 255, 0.2);
    transform: scale(1.05);
  }
  .action-btn:active {
    transform: scale(0.95);
  }
  .action-btn svg {
    width: 20px;
    height: 20px;
    stroke-width: 2;
  }
</style>
<!-- p5 core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
</head>
<body>

<!-- Action Bar -->
<div id="actions" class="fixed top-4 left-4 z-20 flex flex-col gap-3">
  <button id="toggle-ui" class="action-btn" title="Toggle Settings">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
      <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
  </button>
  <button id="clear-canvas" class="action-btn" title="Clear Canvas (C)">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.75L21 3M8.25 15.75L3 21m0-18l18 18" />
    </svg>
  </button>
  <button id="save-canvas" class="action-btn" title="Capture Image">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
    </svg>
  </button>
</div>

<!-- Control Panel (UI) - Now hidden by default -->
<div id="ui" class="fixed top-4 right-4 z-10 p-4 rounded-xl text-xs md:text-sm max-w-xs w-11/12 md:w-auto opacity-0 transform scale-95" style="pointer-events: none;">
  <div class="font-semibold mb-2 text-base text-gray-200">✨ Motion Controls</div>
  <label for="sensitivity" class="block mt-3 mb-1 text-gray-400">Sensitivity (Energy Scaling)</label>
  <input id="sensitivity" type="range" min="0.5" max="2.0" value="1.0" step="0.1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
</div>

<!-- Tip HUD -->
<div id="tip-hud" class="fixed bottom-24 left-1/2 -translate-x-1/2 z-10 text-xl font-medium text-gray-300 opacity-0">
  Unlock Resonance
</div>

<!-- Phase Unlock HUD -->
<div id="phase-hud" class="fixed bottom-8 left-1/2 -translate-x-1/2 z-10 w-3/4 md:w-1/3 h-6 rounded-full p-1 shadow-lg">
  <div id="phase-bar" class="h-full rounded-full" style="width: 0%; transition: width 0.3s ease-out, background-color 0.5s ease;">
    <!-- Bar color is set by JS -->
  </div>
  <div id="phase-label" class="absolute inset-0 flex items-center justify-center text-xs font-bold text-white text-shadow-lg">
    PHASE 1: AWAKENING
  </div>
</div>


<script>
// --- APP STATE AND DOM ELEMENTS ---
let particles = [];
let started = false;
let showIntro = true;
let phase = 1; 

// --- Active Phase Unlock ---
let phaseUnlockProgress = 0;
const PHASE_UNLOCK_GOAL = 60 * 10; // 10 seconds of moderate motion

// --- NEW: Sensor State ---
let sensorData = { accel: { x: 0, y: 0, z: 0 }, gyro: { alpha: 0, beta: 0, gamma: 0 } };
let motionPermission = false;
let orientationPermission = false;
let touchPos = { x: 0, y: 0 };
let currentDisruptionForce = 0;

// --- Physics Constants ---
const MAX_PARTICLES = 700;        // Performance Cap
const GRAVITY_FORCE = 0.03;       // Constant pull towards the center (0,0,0)
const MOUSE_DISRUPT_RADIUS = 300; // 2D radius from mouse
const MOUSE_DISRUPT_FORCE = 0.8;  // How strong the mouse "push" is
const FRICTION = 0.98;            // Damping to prevent infinite acceleration
const BREATHE_FORCE = 0.005;      // Subtle pulse when silent

let introOrbs = [], introStart;

// DOM Elements
const sensitivitySlider = document.getElementById('sensitivity');
const tipHud = document.getElementById('tip-hud');
const phaseBar = document.getElementById('phase-bar');
const phaseLabel = document.getElementById('phase-label');

const uiPanel = document.getElementById('ui');
const toggleUiBtn = document.getElementById('toggle-ui');
const clearCanvasBtn = document.getElementById('clear-canvas');
const saveCanvasBtn = document.getElementById('save-canvas');


// --- Color Palettes ---
const colorMap = [
  // Phase 1: Cool & Ethereal
  { name: "AWAKENING", hue: 200, sat: 80, bgL: 8, pSat: 100, pL: 100, color: 'bg-cyan-500' },
  // Phase 2: Energetic & Warm
  { name: "EXPRESSION", hue: 300, sat: 80, bgL: 10, pSat: 90, pL: 90, color: 'bg-pink-500' },
  // Phase 3: Intense & Gold
  { name: "INTENSITY", hue: 40, sat: 90, bgL: 12, pSat: 95, pL: 80, color: 'bg-yellow-500' },
  // Phase 4: Full Spectrum Shift
  { name: "HARMONY", hue: 180, sat: 90, bgL: 10, pSat: 80, pL: 95, color: 'bg-purple-600' }
];

// --- P5.JS SETUP ---

function setup(){
  createCanvas(windowWidth, windowHeight); // Start 2D for intro
  colorMode(HSB, 360, 100, 100, 100);
  noStroke(); textAlign(CENTER, CENTER);

  for(let i=0;i<30;i++){
    introOrbs.push({
      x: random(width), y: random(height),
      r: random(10, 25), hue: random(180, 320),
      n1: random(1000), n2: random(1000)
    });
  }
  introStart = millis();
  
  // --- Button Listeners ---
  toggleUiBtn.onclick = () => {
    if (uiPanel.style.opacity === '1') {
      uiPanel.style.opacity = '0';
      uiPanel.style.transform = 'scale(0.95)';
      uiPanel.style.pointerEvents = 'none';
    } else {
      uiPanel.style.opacity = '1';
      uiPanel.style.transform = 'scale(1)';
      uiPanel.style.pointerEvents = 'auto';
    }
  };
  
  clearCanvasBtn.onclick = () => clearAllParticles();
  saveCanvasBtn.onclick = () => saveCanvas('my-resonance', 'png');

  // NEW: Touch event setup for mobile disruption
  let canvasElement = document.querySelector('canvas');
  if (canvasElement) {
    canvasElement.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvasElement.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvasElement.addEventListener('touchend', handleTouchEnd);
  }
}

function windowResized(){ 
  resizeCanvas(windowWidth, windowHeight); 
  if (started) {
    perspective(PI / 3.0, width / height, 0.1, 5000);
  }
}

// --- NEW: Sensor Permission & Listeners ---
async function requestSensorAccess() {
  try {
    // iOS quirk: Needs user gesture, so we trigger on button tap (already in drawIntro)
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
      motionPermission = await DeviceMotionEvent.requestPermission();
    } else {
      motionPermission = 'granted'; // Non-iOS fallback
    }
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      orientationPermission = await DeviceOrientationEvent.requestPermission();
    } else {
      orientationPermission = 'granted'; // Non-iOS fallback
    }
    if (motionPermission === 'granted') {
      window.addEventListener('devicemotion', handleMotion);
    }
    if (orientationPermission === 'granted') {
      window.addEventListener('deviceorientation', handleOrientation);
    }
    // Fallback: If denied, use touch/mouse for basic tilt simulation
    setTip("Phone as wand unlocked! Tilt & shake to resonate.", 240);
  } catch (err) {
    console.warn('Sensor access failed:', err);
    setTip("Using touch controls—drag to disrupt!", 200);
  }
}

// --- Sensor Handlers ---
function handleMotion(event) {
  const accel = event.accelerationIncludingGravity;
  if (accel) {
    sensorData.accel = {
      x: accel.x || 0,
      y: accel.y || 0,
      z: accel.z || 0
    };
  }
}
function handleOrientation(event) {
  sensorData.gyro = {
    alpha: event.alpha || 0, // Yaw (left/right)
    beta: event.beta || 0, // Pitch (forward/back)
    gamma: event.gamma || 0 // Roll (tilt left/right)
  };
}

// --- NEW: Touch Handlers (For Disruption & Gestures) ---
function handleTouchStart(e) {
  e.preventDefault();
  const touch = e.touches[0];
  touchPos.x = touch.clientX;
  touchPos.y = touch.clientY;
  currentDisruptionForce = 0;
}
function handleTouchMove(e) {
  e.preventDefault();
  const touch = e.touches[0];
  const deltaX = touch.clientX - touchPos.x;
  const deltaY = touch.clientY - touchPos.y;
  // Map touch drag to 3D disruption (like mouse, but normalized for screen size)
  if (phase >= 4) {
    currentDisruptionForce = map(sqrt(deltaX*deltaX + deltaY*deltaY), 0, 100, 0, MOUSE_DISRUPT_FORCE);
  }
  // Optional: Multi-touch pinch for camera zoom
  if (e.touches.length === 2) {
    // Calculate pinch distance and adjust camera fov or scale
  }
  touchPos.x = touch.clientX;
  touchPos.y = touch.clientY;
}
function handleTouchEnd(e) {
  e.preventDefault();
  currentDisruptionForce = 0;
}

// --- P5.JS DRAW LOOP ---

function draw(){
  if(showIntro){ 
    drawIntro(); // Draw 2D intro
    return; 
  }
  if(!started) return;

  // --- 3D Scene Setup ---
  orbitControl(); 

  const currentPhase = colorMap[min(phase - 1, colorMap.length - 1)];
  
  // --- Sensor-Based "Energy" (Shake/Tilt Intensity) ---
  let tiltIntensity = sqrt(
    sensorData.accel.x**2 + sensorData.accel.y**2 + (sensorData.accel.z - 9.81)**2
  );
  let energy = map(tiltIntensity, 0, 20, 0, 255, true); // Calibrate to your phone's sensitivity
  energy *= parseFloat(sensitivitySlider.value); // Use sensitivity slider
  energy = min(energy, 255);
 
  // Optional: Add gyro for "pitch" variation
  let pitchVar = map(abs(sensorData.gyro.beta), 0, 90, 0, 50);
  energy += pitchVar;
  energy = min(energy, 255);
  
  // --- NEW: Sensor-Controlled Camera Tilt ---
  if (motionPermission === 'granted' || orientationPermission === 'granted') {
    // Map gyro to camera rotation (override orbitControl partially)
    let camBeta = map(sensorData.gyro.beta, -90, 90, -PI/4, PI/4); // Pitch tilt
    let camGamma = map(sensorData.gyro.gamma, -90, 90, -PI/6, PI/6); // Roll tilt
    let camX = sin(camGamma) * 800;
    let camY = sin(camBeta) * 200;
    let camZ = (cos(camGamma) * 800);
    camera(camX, camY, camZ, 0, 0, 0, 0, 1, 0);
  }
  
  // --- Background ---
  let bgLightness = currentPhase.bgL;
  if (phase === 4) {
    // When "loud" (high energy), make the background flash brighter
    bgLightness = map(energy, 0, 255, currentPhase.bgL, currentPhase.bgL + 15, true);
  }
  const bgColor = `hsla(${currentPhase.hue}, ${currentPhase.sat}%, ${bgLightness}%, 0.1)`;
  background(bgColor); 

  // --- Phase Unlocking (Based on Sustained Shake/Tilt) ---
  if (phase < colorMap.length) {
    if (energy > 50) { 
      phaseUnlockProgress += 1;
    } else {
      phaseUnlockProgress = max(0, phaseUnlockProgress - 2); 
    }
    
    if (phaseUnlockProgress > PHASE_UNLOCK_GOAL) {
      phase++;
      phaseUnlockProgress = 0;
      let newPhaseData = colorMap[min(phase - 1, colorMap.length - 1)];
      setTip(`Phase ${phase} Unlocked: ${newPhaseData.name}!`, 240);
      phaseLabel.textContent = `PHASE ${phase}: ${newPhaseData.name}`;
      phaseBar.classList.remove(colorMap[phase-2].color); 
      phaseBar.classList.add(newPhaseData.color); 
    }
    let progressPercent = (phaseUnlockProgress / PHASE_UNLOCK_GOAL) * 100;
    phaseBar.style.width = `${progressPercent}%`;
  } else {
    phaseBar.style.width = `100%`; 
    if(frameCount % 400 === 0) setTip("Touch Disruption Unlocked!", 200);
  }

  // --- Particle Creation (WITH CAP) ---
  if(frameCount % 2 === 0 && energy > 10 && particles.length < MAX_PARTICLES) {
    // Use gyro for centroid-like variation (e.g., alpha for hue offset)
    let simulatedCentroid = map(sensorData.gyro.alpha, 0, 360, 0, 4000);
    particles.push(new Particle(energy, simulatedCentroid, phase));
  }

  // --- Particle Update/Draw ---
  let disruptionForce = currentDisruptionForce;
  for(let i=particles.length-1;i>=0;i--){
    particles[i].update(energy, disruptionForce); // Pass energy and disruption
    particles[i].show(currentPhase);
    if(particles[i].dead()) particles.splice(i,1);
  }
  
  if(energy < 10 && frameCount % 360 === 0) setTip("Tilt and shake to shape the cosmos.", 180);
}

// --- Intro Screen (2D) ---
function drawIntro(){
  background(0,0,8, 12); 
  noStroke();

  const t = (millis() - introStart) * 0.00025;
  for(const o of introOrbs){
    o.x += map(noise(o.n1 + t), 0, 1, -0.8, 0.8);
    o.y += map(noise(o.n2 + t), 0, 1, -0.8, 0.8);
    if(o.x<-50) o.x=width+50; if(o.x>width+50) o.x=-50;
    if(o.y<-50) o.y=height+50; if(o.y>height+50) o.y=-50;
    
    const orbHue = (o.hue + frameCount * 0.2) % 360;
    fill(orbHue, 50, 60, 12); circle(o.x, o.y, o.r * 3.5);
    fill(orbHue, 80, 85, 30); circle(o.x, o.y, o.r * 1.5);
  }
  
  const breath = 1 + 0.04 * sin((millis() - introStart) * 0.003);
  push(); 
  translate(width/2, height/2 - 90); 
  scale(breath);
  fill(0, 0, 100); 
  textSize(48); 
  text("Resonance of You", 0, 0); 
  pop();

  const alpha = map(sin((millis() - introStart) * 0.002), -1, 1, 40, 80);
  fill(0, 0, 100, alpha); 
  textSize(20);
  text("Your motion crafts the cosmos.\nTap to awaken with your phone!", width/2, height/2 - 20);

  const x = width/2 - 120, y = height/2 + 40, w = 240, h = 60, r = 30;
  const hov = mouseX > x && mouseX < x + w && mouseY > y && mouseY < y + h;
  fill(250, 80, 90, hov ? 100 : 90); 
  rect(x, y, w, h, r);
  fill(0, 0, 0); 
  textSize(20); 
  text("Begin Experience", x + w/2, y + h/2 + 2);

  if(mouseIsPressed && hov) startExperience();
}

function startExperience(){
  if(started) return;
  
  createCanvas(windowWidth, windowHeight, WEBGL); // Switch to 3D
  perspective(PI / 3.0, width / height, 0.1, 5000);
  colorMode(HSB, 360, 100, 100, 100); 
  
  // NEW: Request sensors 
  requestSensorAccess().then(() => {
    started = true; showIntro = false;
    setTip("Shake & tilt to awaken the particles!", 240);
    phaseBar.classList.add(colorMap[0].color); 
  });
}

// --- Clear Function ---
function clearAllParticles() {
  if (!started) return;
  particles = []; // Instant reset
  setTip("Canvas Cleared", 120);
}

// --- Key Listener ---
function keyPressed() {
  if (key === 'c' || key === 'C') {
    clearAllParticles();
  }
}

// --- UI / Feedback Helpers (Controls HTML) ---
function setTip(msg, durationFrames){
  tipHud.textContent = msg;
  tipHud.style.opacity = 1;
  
  setTimeout(() => {
    tipHud.style.opacity = 0;
  }, (durationFrames * 1000) / 60); // Convert frames to ms
}


// --- 3D Particle Class ---
class Particle{
  constructor(energy, centroid, currentPhase){
    this.x = random(-20, 20); 
    this.y = random(-20, 20);
    this.z = random(-20, 20);
    this.phase = currentPhase;
    this.hue = map(centroid, 0, 4000, 180, 360, true); 
    
    // --- Phase 4 Randomized Shape ---
    if (this.phase === 4) {
      // Assign a random *render type* from phases 1, 2, or 3
      this.renderType = floor(random(1, 4)); // 1, 2, or 3
    } else {
      this.renderType = this.phase;
    }
    
    let vScale = map(energy, 0, 255, 1, 3);
    this.vx = random(-vScale, vScale);
    this.vz = random(-vScale, vScale);
    this.vy = map(centroid, 0, 3000, 3, -3, true) + random(-0.5, 0.5);

    this.ax = 0; this.ay = 0; this.az = 0;
    this.life = 255; 
    this.size = map(energy, 0, 255, 1, 10);
  }
  
  update(energy, disruptionForce = 0){
    // 1. Reset acceleration
    this.ax = 0; this.ay = 0; this.az = 0;

    // 2. Apply Force 1: Gravity (Orbital pull to center)
    let toCenter = createVector(-this.x, -this.y, -this.z);
    toCenter.setMag(GRAVITY_FORCE); 
    this.ax += toCenter.x;
    this.ay += toCenter.y;
    this.az += toCenter.z;
    
    // 3. Apply Force: Touch/Sensor Disruption (Phase 4 Only)
    if (phase === 4 && disruptionForce > 0) {
      // Apply radial repel based on touch position (map to 3D)
      let touch3D_X = map(touchPos.x, 0, width, -width/2, width/2);
      let touch3D_Y = map(touchPos.y, 0, height, height/2, -height/2); // Invert Y for 3D
      let touch3D_Z = 0; // Assume on XY plane
      let toTouch = createVector(this.x - touch3D_X, this.y - touch3D_Y, this.z - touch3D_Z);
      let dist = toTouch.mag();
      if (dist < MOUSE_DISRUPT_RADIUS) {
        toTouch.normalize();
        toTouch.mult(disruptionForce);
        this.ax += toTouch.x;
        this.ay += toTouch.y;
        this.az += toTouch.z;
      }
    } 
    // 4. Apply Force 3: Breathing (When silent)
    else if (energy < 10) {
      let pulse = sin(frameCount * 0.02 + (this.life * 0.01)) * BREATHE_FORCE;
      let breatheVec = createVector(this.x, this.y, this.z).normalize();
      this.ax += breatheVec.x * pulse;
      this.ay += breatheVec.y * pulse;
      this.az += breatheVec.z * pulse;
    }

    // 5. Update Velocity
    this.vx += this.ax;
    this.vy += this.ay;
    this.vz += this.az;

    // 6. Apply Damping/Friction
    this.vx *= FRICTION;
    this.vy *= FRICTION;
    this.vz *= FRICTION;

    // 7. Update Position
    this.x += this.vx; 
    this.y += this.vy; 
    this.z += this.vz; 
    
    this.life -= 1.0; 
  }

  // --- PHASE-BASED RENDERING ---
  show(currentPhaseData){
    push(); 
    translate(this.x, this.y, this.z); 
    
    let currentHue = (this.hue + frameCount * (0.5 * phase)) % 360;
    let alpha = this.life / 2.5; 
    let sat = currentPhaseData.pSat;
    let light = currentPhaseData.pL;

    // --- Use renderType ---
    switch(this.renderType) {
      case 1: // Phase 1: Spheres
        noStroke(); 
        fill(currentHue, sat, light, alpha); 
        sphere(this.size); 
        stroke(currentHue, sat, light, alpha / 4); 
        strokeWeight(1);
        line(0, 0, 0, -this.vx * 4, -this.vy * 4, -this.vz * 4); 
        break;

      case 2: // Phase 2: Cubes
        noStroke();
        fill(currentHue, sat, light, alpha);
        rotateX(this.life * 0.05); 
        rotateY(this.life * 0.05);
        box(this.size * 1.5); 
        stroke(currentHue, sat, light, alpha / 2);
        strokeWeight(2);
        line(0, 0, 0, -this.vx * 8, -this.vy * 8, -this.vz * 8); 
        break;

      case 3: // Phase 3: Tori (Donuts)
        noFill();
        strokeWeight(this.size / 3);
        let strobeAlpha = alpha * (0.5 + 0.5 * sin(this.life * 0.2)); 
        stroke(currentHue, sat, light, strobeAlpha);
        rotateX(this.life * -0.05);
        rotateY(this.life * 0.03);
        torus(this.size * 2, this.size * 0.5);
        break;
        
      // Note: Case 4 is no longer used for rendering new particles
      case 4: 
        noStroke(); 
        fill(currentHue, sat, light, alpha); 
        sphere(this.size); 
        break;
    }
    
    pop(); 
  }
  
  dead(){ return this.life <= 0; }
}

</script>
</body>
</html>